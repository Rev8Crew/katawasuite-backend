<?php

namespace Modules\KatawaCore\v2\Modules\GameModel;

use Illuminate\Support\Str;
use Modules\KatawaCore\v2\KatawaCore;
use Modules\KatawaCore\v2\Modules\Configs\Config;
use Modules\KatawaCore\v2\Modules\Tools\GamePath;
use Modules\KatawaCore\v2\Modules\Tools\Tools;

final class CharacterModel extends ModelWith
{
    public const COMMAND = 'img';

    public const NAME_PREFIX = '@';

    public string $name;

    public string $path;

    public bool $isInvisible = false;

    private bool $isReplacedLongName = false;

    public function parse(): CharacterModel
    {
        $name = $this->line->get(KatawaCore::ARG_FIRST);
        $path = $this->line->get(KatawaCore::ARG_SECOND);

        if ($path === 'at') {
            $path = null;
        }

        $this->name = $name;

        if ($this->name === 'sonya') {

            $path = $this->line->get(KatawaCore::ARG_SECOND) . '/' . $this->line->get(KatawaCore::ARG_THIRD);

            #show sonya form red_eye nohappy1 with dissolve
            if (
                $this->line->get(KatawaCore::ARG_SECOND) === 'dress' &&
                $this->line->get(KatawaCore::ARG_THIRD) === 'red_eye'
            ) {
                $path = $this->line->get(KatawaCore::ARG_SECOND) . ' '
                    . $this->line->get(KatawaCore::ARG_THIRD) . '/'
                    . $this->line->get(KatawaCore::ARG_FOURTH);
            }
        }

        if ($path) {
            $path = $this->replaceNightPath($path);
        }

        $this->path = $this->setPath($path);
        $this->name = $this->replaceCharacter($name);

        $this->position();

        return parent::parse(); // TODO: Change the autogenerated stub
    }

    public function hide($seconds = 0.5)
    {
        $this->name = $this->line->get(KatawaCore::ARG_FIRST);
        $this->path = '~';

        if ($this->name === 'muto') {
            $this->name = '';
        }

        $this->setIsSkipped();
        $this->positionTime($seconds);

        return $this;
    }

    public function compile(): string
    {
        $output = self::COMMAND;

        if ($this->name) {
            $output .= ' '.self::NAME_PREFIX.$this->name;
        }

        if ($this->path) {
            $output .= ' '.$this->path;
        }

        $parent = parent::compile();
        if ($parent) {
            $output .= ' '.$parent;
        }

        return $output;
    }

    private function setPath(?string $path): string
    {
        $pathOfExile = $path ?: $this->name;
        /**
         * @var array{dissolve: bool, path: string} $item
         */
        foreach (Config::getInstance()->getConfigValue('replace_characters_path') as $character => $item) {
            if ($this->name === $character) {
                if ($item['dissolve']) {
                    $this->dissolve(1.0);
                }

                return Tools::quoted($item['path']);
            }
        }

        if (strpos($pathOfExile, 'invis') !== false) {
            $this->isInvisible = true;

            return '';
        }

        $gamePath = GamePath::getInstance();

        $fixNamePathIfRequired = $this->replaceCharacter($this->name);

        $canBeUsedAsPath = $this->name.'_'.$pathOfExile.'.png';
        if ($this->isReplacedLongName) {
            $canBeUsedAsPath = $pathOfExile.'.png';
        }

        if ($this->name === 'sonya') {
            $canBeUsedAsPath =$pathOfExile.'.png';
        }

        foreach ($this->getForegroundPaths($fixNamePathIfRequired, $canBeUsedAsPath) as $paths) {
            if ($gamePath->exists($paths['path'])) {
                if ($paths['config_value']) {
                    return Tools::quoted($fixNamePathIfRequired.'/'.$paths['config_value'].'/'.$canBeUsedAsPath);
                }

                return Tools::quoted($fixNamePathIfRequired.'/'.$canBeUsedAsPath);
            }
        }

        \rr\dd(
            '[Character Model] File not found',
            $this->getForegroundPaths($fixNamePathIfRequired, $canBeUsedAsPath),
            $this->line->implode(' '),
            $path
        );

        return '';
    }

    private function getForegroundPaths($characterName, $characterPath): array
    {
        $gamePath = GamePath::getInstance();

        $paths = [];

        $paths[] = [
            'path' => $gamePath->getForegroundSubPath($characterName).$characterPath,
            'config_value' => '',
        ];

        foreach (Config::getInstance()->getConfigValue('characters_lookup_path') as $item) {
            $tempPath = Str::startsWith($item, '/') ? $gamePath->getForegroundSubPath(substr($item, 1)).$characterPath :
                $gamePath->getForegroundSubPath($characterName.'/'.$item).$characterPath;

            $paths[] = [
                'path' => $tempPath,
                'config_value' => $item,
            ];
        }

        return $paths;
    }

    /** Заменяет персонажей
     */
    private function replaceCharacter($character): string
    {
        foreach (Config::getInstance()->getConfigValue('replace_characters') as $key => $value) {
            if ($key === $character) {
                return $value;
            }
        }

        foreach (Config::getInstance()->getConfigValue('replace_long_characters') as $key => $value) {
            // Если строка начинается с нужной
            if (strpos($character, $key) === 0) {
                $this->isReplacedLongName = true;

                return $value;
            }
        }

        return $character;
    }

    private function replaceNightPath(string $path): string
    {
        if (stripos($path, '_ni') === strlen($path) - 3) {
            $path = substr($path, 0, -3);
        }

        return str_replace(['_ss', '_fb', '_rn', '_nl'], '', $path);
    }
}
